from __future__ import division, print_function

import sys
import os
import importlib
import numpy as np
import tensorflow as tf
from scipy import signal
from safe_learning import DeterministicFunction
from safe_learning import config
from safe_learning.utilities import concatenate_inputs
if sys.version_info.major == 2:
    import imp


__all__ = ['import_from_directory', 'InvertedPendulum']


def import_from_directory(library, path):
    """Import a library from a directory outside the path.

    Parameters
    ----------
    library: string
        The name of the library.
    path: string
        The path of the folder containing the library.
    """
    try:
        return importlib.import_module(library)
    except ImportError:
        module_path = os.path.abspath(path)
        version = sys.version_info

        if version.major == 2:
            f, filename, desc = imp.find_module(library, [module_path])
            return imp.load_module(library, f, filename, desc)
        else:
            sys.path.append(module_path)
            return importlib.import_module(library)


class InvertedPendulum(DeterministicFunction):
    """Inverted Pendulum.

    Parameters
    ----------
    mass : float
    length : float
    friction : float, optional
    dt : float, optional
        The sampling time.
    normalization : tuple, optional
        A tuple (Tx, Tu) of arrays used to normalize the state and actions. It
        is so that diag(Tx) *x_norm = x and diag(Tu) * u_norm = u.
    """

    def __init__(self, mass, length, friction=0, dt=1 / 80,
                 normalization=None):
        super(InvertedPendulum, self).__init__()
        self.mass = mass
        self.length = length
        self.gravity = 100
        self.friction = friction
        self.dt = dt

        self.normalization = normalization
        if normalization is not None:
            self.normalization = [arr.astype(config.np_dtype) for
                                  arr in normalization]
            self.inv_norm = [arr ** -1 for arr in self.normalization]

    @property
    def inertia(self):
        """The inertia of the pendulum"""
        return self.mass * self.length ** 2

    def normalize(self, state, action):
        """Normalize states and actions."""
        if self.normalization is None:
            return state, action

        Tx_inv, Tu_inv = map(np.diag, self.inv_norm)
        state = tf.matmul(state, Tx_inv)

        if action is not None:
            action = tf.matmul(action, Tu_inv)

        return state, action

    def denormalize(self, state, action):
        """Denormalize states and actions"""
        if self.normalization is None:
            return state, action

        Tx, Tu = map(np.diag, self.normalization)

        state = tf.matmul(state, Tx)
        if action is not None:
            action = tf.matmul(action, Tu)

        return state, action

    def linearize(self):
        """Return the linearized system.

        Returns
        -------
        a : ndarray
            The state matrix.
        b : ndarray
            The action matrix.
        """
        gravity = self.gravity
        length = self.length
        friction = self.friction
        inertia = self.inertia

        A = np.array([[0, 1],
                      [gravity / length, -friction / inertia]],
                     dtype=config.np_dtype)

        B = np.array([[0],
                      [1 / inertia]],
                     dtype=config.np_dtype)

        if self.normalization is not None:
            Tx, Tu = map(np.diag, self.normalization)
            Tx_inv, Tu_inv = map(np.diag, self.inv_norm)

            A = np.linalg.multi_dot((Tx_inv, A, Tx))
            B = np.linalg.multi_dot((Tx_inv, B, Tu))

        sys = signal.StateSpace(A, B, np.eye(2), np.zeros((2, 1)))
        sysd = sys.to_discrete(self.dt)
        return sysd.A, sysd.B

    @concatenate_inputs(start=1)
    def build_evaluation(self, state_action):
        """Evaluate the dynamics"""
        # Denormalize
        state, action = tf.split(state_action, [2, 1], axis=1)
        state, action = self.denormalize(state, action)

        n_inner = 10
        dt = self.dt / n_inner
        for i in range(n_inner):
            state_derivative = self.ode(state, action)
            state = state + dt * state_derivative

        return self.normalize(state, None)[0]

    def ode(self, state, action):
        """Compute the state time-derivative.

        Parameters
        ----------
        states: ndarray or Tensor
            Unnormalized states.
        actions: ndarray or Tensor
            Unnormalized actions.

        Returns
        -------
        x_dot: Tensor
            The normalized derivative of the dynamics
        """

        # Physical dynamics
        gravity = self.gravity
        length = self.length
        friction = self.friction
        inertia = self.inertia

        angle, angular_velocity = tf.split(state, 2, axis=1)

        x_ddot = gravity / length * angle + action / inertia

        if friction > 0:
            x_ddot -= friction / inertia * angular_velocity

        state_derivative = tf.concat((angular_velocity, x_ddot), axis=1)

        # Normalize
        return state_derivative

class SpringDamper(DeterministicFunction):
    """SpringDamper
        
        Parameters
        ----------
        k: stiffness of the spring (N/m)
        c: damping coefficient (kg Â· m/s2)
        m: mass of the block (kg)
        F: external force (N)
        dt : float, optional
        The sampling time.
        normalization : tuple, optional
        A tuple (Tx, Tu) of arrays used to normalize the state and actions. It
        is so that diag(Tx) *x_norm = x and diag(Tu) * u_norm = u.
        """
    
    def __init__(self, m, mass, c=0, dt=1 / 80,
                 normalization=None):
        super(SpringDamper, self).__init__()
        self.m = m
        self.mass = mass
        self.k = 100
        self.c = c
        self.dt = dt
        
        self.normalization = normalization
        if normalization is not None:
            self.normalization = [arr.astype(config.np_dtype) for
                                  arr in normalization]
            self.inv_norm = [arr ** -1 for arr in self.normalization]

     #@property
    #def inertia(self):
    #    """The inertia of the pendulum"""
    #    return self.mass * self.length ** 2
    
    def normalize(self, state, action):
        """Normalize states and actions."""
        if self.normalization is None:
            return state, action
    
        Tx_inv, Tu_inv = map(np.diag, self.inv_norm)
        state = tf.matmul(state, Tx_inv)
        
        if action is not None:
            action = tf.matmul(action, Tu_inv)

        return state, action
    
    def denormalize(self, state, action):
        """Denormalize states and actions"""
        if self.normalization is None:
            return state, action
    
        Tx, Tu = map(np.diag, self.normalization)
        
        state = tf.matmul(state, Tx)
        if action is not None:
            action = tf.matmul(action, Tu)

        return state, action
    
    def linearize(self):
        """Return the linearized system.
            
            Returns
            -------
            a : ndarray
            The state matrix.
            b : ndarray
            The action matrix.
            """
        k = self.k
        mass = self.mass
        c = self.c
        m = self.m
        
        A = np.array([[0, 1],
                      [k / mass, -c / m]],
                     dtype=config.np_dtype)
            
        B = np.array([[0],[1 / (m * mass ** 2)]],dtype=config.np_dtype)
                     
        if self.normalization is not None:
            Tx, Tu = map(np.diag, self.normalization)
            Tx_inv, Tu_inv = map(np.diag, self.inv_norm)
                     
            A = np.linalg.multi_dot((Tx_inv, A, Tx))
            B = np.linalg.multi_dot((Tx_inv, B, Tu))

        sys = signal.StateSpace(A, B, np.eye(2), np.zeros((2, 1)))
        sysd = sys.to_discrete(self.dt)
        return sysd.A, sysd.B
    
    @concatenate_inputs(start=1)
    def build_evaluation(self, state_action):
        """Evaluate the dynamics"""
        # Denormalize
        state, action = tf.split(state_action, [2, 1], axis=1)
        state, action = self.denormalize(state, action)
        
        n_inner = 10
        dt = self.dt / n_inner
        for i in range(n_inner):
            state_derivative = self.ode(state, action)
            state = state + dt * state_derivative
        
        return self.normalize(state, None)[0]
    
    def ode(self, state, action):
        """Compute the state time-derivative.
            
            Parameters
            ----------
            states: ndarray or Tensor
            Unnormalized states.
            actions: ndarray or Tensor
            Unnormalized actions.
            
            Returns
            -------
            x_dot: Tensor
            The normalized derivative of the dynamics
            """
        
        # Physical dynamics
        k = self.k
        mass = self.mass
        c = self.c
        m = self.m
        
        angle, angular_velocity = tf.split(state, 2, axis=1)
        
        x_ddot = k / mass * angle + action / m
        
        if c > 0:
            x_ddot -= c / m * angular_velocity
        
        state_derivative = tf.concat((angular_velocity, x_ddot), axis=1)
        
        # Normalize
        return state_derivative
